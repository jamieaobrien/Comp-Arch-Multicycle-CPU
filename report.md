# CompArch Lab3: Single Cycle CPU
### Sabrina, Liv, and Jamie

## Processor Architecture

![](./Images/Final_CPU.png)

Above is the overview diagram for our single-cycle CPU. The instruction memory feeds into the decoder, which finds the important information from the instruction by splitting the 32 bit binary number into Rs, Rt, Rd, Imm16, address, opcode, and funct according to the MIPS format. The first four feed into the calculation circuit, while func and opcode inform the control logic. The choose module ensure that the PC is always correct depending on the operation being executed, i.e. jumps, branches, or other operations. The register file and ALU are in the calculation circuitry. The Rs, Rt, Rd fetch operand registers and Imm16 selects immediate values. These values feed into the ALU, and depending on the instruction, can be used to read or store into the CPU registers or memory. The control logic that opcode and funct influence produces control signals that influence the ALU calculations through peripheral circuitry and allow more complex actions to occur.  

The opcode feeds into the address generator, which produces jump_addr, branch_addr, and PC4. The address generator modifies the branch and jump information, which allows the choose module to respond to different jump and branch commands. These two modules together effectively function as the program counter, which controls how the CPU iterates through different instructions. The interaction between the elements of this data path allow the CPU to continuously perform calculations after an external reset is set and save them to memory files. 

![](./Images/choose.png)

The above diagram is a closer loop at program counter, which consists of the choose circuitry and address generator. The address generator produces a value representing PC4, which is the PC value plus 4. This then feeds into a mux that either passes this value on or resets everything to 0. That output then feeds into another mux that uses an AND gate with Jump and reset as the select line. If jump and reset are true, the mux will pass on the jump address, which is generated by the address generator and determines whether the jump behavior is jumpreg, jump and link, or jump. The output of this jump-related mux is then passed through another mux that relates to different branch commands. The circuitry that feeds into the select line of the branch-related mux includes another mux that chooses between bne and beq, which are flags that are high if BNE or BEQ are the current operation, respectively, and an or gate that includes bne and beq. This feeds into an and gate along with reset to determine whether the branch address should become the PC counter. The output of the branch-related mux will therefore be a branch address, reset, PC+4, or a jump address. This will be stored in a register file so that it can be fed into the address generator to determine the next PC. 

![](./Images/calculation.png)

If we take a closer look at the calculation circuitry, we can see that it consists of a reg file split into two parts, a memory file, an ALU, and three muxes that control what is inputted into the ALU and what is written to the register. First, the reg file takes in Rs and Rt into its inputs. Then, R[Rs] is passed directly into the ALU and R[Rt] is passed into a mux controlled by ALUSrc (ALU source) that determines whether R[Rs] or an immediate is fed into the ALU. R[Rt] and R[Rs] are then used by the ALU, which is controlled by the ALUcntrl (ALU control) signal. At the same time, the R[Rt] is written into the memory file if MemWr is high.The operation the ALUcntrl signal chooses is performed and the result is sent to a mux that determines whether the result, memory data, or a plus 4 is written to the data write of the register (shown on register part 2). The mux feeding into the Aw (address write) determines where the data is stored: Rd, 31 (required for jump and link), and Rt. The RegDst (register destination) select line chooses between the three. 

In our implementation of the described CPU design we reused multiple files from previous labs. Specifically, the alu, regfile, register, muxes, and gitignore (as well as corresponding test benches for registers/alu) were borrowed from our earlier work.

## Testing
   
   We tested each part of our CPU circuit using test benches we created in verilog that compared expected values to our cpu results. In each case, we found that our predicted values matched our expected. 
   
![](./Images/alu.png)

The above testbench is the verilog testbench for the alu. We tested the addition, subtraction, SLT, Nand, And, Xor, Nor, and Or tests. Each test passed. We borrowed the ALU file from lab 1, so this test bench is identical. 

![](./Images/controlLogic.png)

We created this testbench for the control logic look up table. This test bench is essentially just our look up table's values, which we tested to ensure that for each operation, the lookup table returned control signals that would ensure that the operations are executed successfully. We found the control signals were correct for all operations, so this test passes. 

![](./Images/decoder.png)

The decoder test bench inputs an easy to parse instruction that switches between 0s and 1s for each part of the instruction. It then set up a series of expected values and compared them to the returned output from the decoder. (For example, the expected value for the opcode is the first six zeros from the instruction. We set up a variable testOpcode and checked if that was the same as the opcode output. It was, so it returned 1 for true.) We can see that for each of the three different instruction types (pulled directly from the basic instruction formats on the MIPs sheet), the decoder returns the expected instructions, so each of the tests passed. 

![](./Images/PCchoose.png)

We tested the PC circuit by inputting different values for the zero, jump, and reset select lines and the bne and beq inputs. We also inputted different values for currentPC, branchAddr, jumpAddr, and newPC. We then tested to see if the results aligned with what we expected. We found that each of the tested scenarios matched the predicted. 

![](./Images/regfile.png)

We took the DUT test of the reg file, we took the reg file from homework 4 and the corresponding test bench and reused them. We found that the regfile still passed. 

![](./Images/PCaddrGen.png)

Finally, we created a testbench for the address generator. It takes in different address, immediate, opcode, R_rs, and PC and produces different PC4, branchAddress and jumpAddress values. We manually checked that the outputs made sense. We found that they did, so these tests passed.

We ran a series of tests that included each one of the operations. We managed to get every operation functional. We're unclear whether stacks are functioning as expected as it seems like when we ran the spin.asm test and we saw that there were issues with addi and negative values that prevented effective use of the stack. We would have investigated further, but we were out of time. 

![](./Images/test2.png)

The above waveform is a simple test we wrote to test ADDI, SUB, ADD, STORE WORD, and LOAD WORD. At marker A the stack pointer is set to the given value. At marker B ADDI stores 7 in V0. At C ADDI sets V1 to 3. At marker D We store the subtraction between the value stored in v0 (7) and the value stored in v1 (3) and we see we get 4. At marker E we add between registers, which undoes the subtraction operation. At marker F we store the data from V0 at address SP. 

## Performance and Design Analysis
   
For a linear program we know the cycles required for program completion would be equivalent to the number of instructions as it is a single cycle CPU. However, a program with function calls will require more cycles to complete than the number of instructions. 

We looked at the different instruction types and different instructions take different times. The jumps will take the least time, instructions that require writing will take longer than instructions that only require reading. 
